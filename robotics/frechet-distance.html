<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fréchet Distance Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .btn {
            @apply px-4 py-2 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2;
        }
        .btn-blue { @apply bg-blue-500 hover:bg-blue-600 focus:ring-blue-400; }
        .btn-red { @apply bg-red-500 hover:bg-red-600 focus:ring-red-400; }
        .btn-green { @apply bg-green-500 hover:bg-green-600 focus:ring-green-400; }
        .btn-gray { @apply bg-gray-400 hover:bg-gray-500 focus:ring-gray-300; }
        .btn-orange { @apply bg-orange-500 hover:bg-orange-600 focus:ring-orange-400; }
        .btn-disabled { @apply bg-gray-300 cursor-not-allowed hover:scale-100; }

        .table-cell-highlight { background-color: #fefcbf; transition: background-color 0.2s ease-in-out; }
        .table-cell-path { background-color: #dbeafe; transition: background-color 0.2s ease-in-out; }
        .table-cell-traceback { background-color: #f0abfc; border: 2px solid #c026d3; }
        .table-cell-final { background-color: #a7f3d0; font-weight: bold; }
        #dpTable td, #dpTable th { @apply border border-gray-300 p-2 text-center text-xs; min-width: 60px; }
        
        /* Toggle Switch Styles */
        .toggle-checkbox:checked { @apply: right-0 border-green-400; right: 0; }
        .toggle-checkbox:checked + .toggle-label { @apply: bg-green-400; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl bg-white rounded-xl shadow-2xl p-6">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Interactive Fréchet Distance</h1>
        <p class="text-center text-gray-500 mb-6">Click on the canvas to draw two paths, then calculate their similarity.</p>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <div class="flex flex-col">
                <canvas id="drawingCanvas" class="w-full h-96 bg-white border-2 border-gray-300 rounded-lg cursor-crosshair"></canvas>
                
                <div class="flex flex-wrap items-center justify-center gap-3 mt-4">
                    <button id="drawCurve1Btn" class="btn btn-blue">Draw Curve 1 (Blue)</button>
                    <button id="drawCurve2Btn" class="btn btn-red">Draw Curve 2 (Red)</button>
                    <button id="calculateBtn" class="btn btn-green">Calculate Distance</button>
                    <button id="resetBtn" class="btn btn-gray">Reset</button>
                </div>
                
                <!-- New Controls for Step Mode -->
                <div class="flex flex-col items-center justify-center gap-3 mt-4">
                    <div class="flex items-center">
                        <label for="stepModeToggle" class="text-gray-600 mr-3">Step by Step Mode</label>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle" id="stepModeToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                            <label for="stepModeToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                        </div>
                    </div>
                    <button id="nextStepBtn" class="btn btn-orange hidden">Next Step &rarr;</button>
                </div>

                <div id="result" class="mt-4 text-center h-12">
                    <p id="status" class="text-lg text-gray-600 font-medium">Select a curve to start drawing.</p>
                </div>
            </div>

            <div class="flex flex-col items-center justify-center bg-gray-50 p-4 rounded-lg border border-gray-200 min-h-[400px]">
                 <p id="table-placeholder" class="text-gray-400">The distance table will be generated here.</p>
                 <div id="tableContainer" class="w-full overflow-auto"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const drawCurve1Btn = document.getElementById('drawCurve1Btn');
        const drawCurve2Btn = document.getElementById('drawCurve2Btn');
        const calculateBtn = document.getElementById('calculateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const resultDiv = document.getElementById('result');
        const statusP = document.getElementById('status');
        const tableContainer = document.getElementById('tableContainer');
        const tablePlaceholder = document.getElementById('table-placeholder');
        const stepModeToggle = document.getElementById('stepModeToggle');
        const nextStepBtn = document.getElementById('nextStepBtn');

        let curve1Points = [];
        let curve2Points = [];
        let currentCurve = 0;
        let isCalculating = false;
        let isStepMode = false;
        let calculationGenerator = null;
        const ANIMATION_SPEED = 150;

        // --- Canvas Setup and Drawing ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            redrawCanvas();
        }

        function redrawCanvas(leash = null, pathLeashes = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCurve(curve1Points, '#3b82f6', 'P');
            drawCurve(curve2Points, '#ef4444', 'Q');
            pathLeashes.forEach(l => drawLeash(l.p1, l.p2, '#c026d3'));
            if (leash) {
                drawLeash(leash.p1, leash.p2, '#f59e0b');
            }
        }

        function drawCurve(points, color, labelPrefix) {
            if (points.length === 0) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            points.forEach((p, index) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`${labelPrefix}${index}`, p.x + 8, p.y - 8);
            });
        }
        
        function drawLeash(p1, p2, color) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        canvas.addEventListener('mousedown', (e) => {
            if (currentCurve === 0 || isCalculating) return;
            const rect = canvas.getBoundingClientRect();
            const point = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            (currentCurve === 1 ? curve1Points : curve2Points).push(point);
            redrawCanvas();
        });

        // --- Control Logic ---
        function setDrawingMode(mode) {
            currentCurve = mode;
            drawCurve1Btn.classList.toggle('ring-4', mode === 1);
            drawCurve1Btn.classList.toggle('ring-blue-300', mode === 1);
            drawCurve2Btn.classList.toggle('ring-4', mode === 2);
            drawCurve2Btn.classList.toggle('ring-red-300', mode === 2);
            statusP.textContent = mode ? `Drawing Curve ${mode}. Click on the canvas.` : 'Select a curve to start drawing.';
        }

        stepModeToggle.addEventListener('change', (e) => {
            isStepMode = e.target.checked;
        });

        nextStepBtn.addEventListener('click', () => {
            if (calculationGenerator) {
                calculationGenerator.next().then(result => {
                    if (result.done) {
                        calculationGenerator = null;
                    }
                });
            }
        });

        drawCurve1Btn.addEventListener('click', () => setDrawingMode(1));
        drawCurve2Btn.addEventListener('click', () => setDrawingMode(2));

        resetBtn.addEventListener('click', () => {
            curve1Points = [];
            curve2Points = [];
            isCalculating = false;
            calculationGenerator = null;
            setDrawingMode(0);
            redrawCanvas();
            tableContainer.innerHTML = '';
            tablePlaceholder.style.display = 'block';
            resultDiv.innerHTML = '<p id="status" class="text-lg text-gray-600 font-medium">Select a curve to start drawing.</p>';
            toggleButtons(true);
            nextStepBtn.classList.add('hidden');
        });

        calculateBtn.addEventListener('click', () => {
            if (curve1Points.length < 1 || curve2Points.length < 1) {
                alert('Please draw at least one point for each curve.');
                return;
            }
            isCalculating = true;
            toggleButtons(false);
            statusP.textContent = 'Calculating...';
            
            if (isStepMode) {
                nextStepBtn.classList.remove('hidden');
                calculationGenerator = frechetDistanceGenerator(curve1Points, curve2Points);
                calculationGenerator.next();
            } else {
                runAutoFrechet(curve1Points, curve2Points);
            }
        });

        function toggleButtons(enabled) {
            const buttons = [drawCurve1Btn, drawCurve2Btn, calculateBtn, resetBtn, stepModeToggle];
            buttons.forEach(btn => {
                btn.disabled = !enabled;
                if(btn.tagName === 'INPUT') {
                    btn.parentElement.classList.toggle('opacity-50', !enabled);
                } else {
                    btn.classList.toggle('btn-disabled', !enabled);
                }
            });
        }

        // --- Fréchet Distance Logic & Animation ---
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        
        function createDPTable(m, n) {
            tablePlaceholder.style.display = 'none';
            let tableHTML = '<table id="dpTable" class="border-collapse"><thead><tr><th></th>';
            for (let j = 0; j < n; j++) tableHTML += `<th>Q${j}</th>`;
            tableHTML += '</tr></thead><tbody>';
            for (let i = 0; i < m; i++) {
                tableHTML += `<tr><th>P${i}</th>`;
                for (let j = 0; j < n; j++) tableHTML += `<td id="cell-${i}-${j}"></td>`;
                tableHTML += '</tr>';
            }
            tableHTML += '</tbody></table>';
            tableContainer.innerHTML = tableHTML;
        }

        async function runAutoFrechet(P, Q) {
            const generator = frechetDistanceGenerator(P, Q);
            for await (const _ of generator) {}
        }

        async function* frechetDistanceGenerator(P, Q) {
            const m = P.length;
            const n = Q.length;
            createDPTable(m, n);
            const ca = Array(m).fill(null).map(() => Array(n).fill(-1));

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    const currentDist = euclideanDistance(P[i], Q[j]);

                    // STAGE 1: Show current distance
                    cell.classList.add('table-cell-highlight');
                    cell.textContent = `d=${currentDist.toFixed(1)}`;
                    redrawCanvas({ p1: P[i], p2: Q[j] });
                    if (!isStepMode) await sleep(ANIMATION_SPEED * 1.5);
                    yield;

                    // STAGE 2: Highlight previous cells and find minimum
                    let prevDist = 0;
                    const candidates = [];
                    if (i > 0) candidates.push({ val: ca[i-1][j], id: `cell-${i-1}-${j}` });
                    if (j > 0) candidates.push({ val: ca[i][j-1], id: `cell-${i}-${j-1}` });
                    if (i > 0 && j > 0) candidates.push({ val: ca[i-1][j-1], id: `cell-${i-1}-${j-1}` });
                    
                    let minPrevCellId = null;
                    if (candidates.length > 0) {
                        candidates.forEach(c => document.getElementById(c.id)?.classList.add('table-cell-path'));
                        const minCand = candidates.sort((a,b) => a.val - b.val)[0];
                        prevDist = minCand.val;
                        minPrevCellId = minCand.id;
                        document.getElementById(minPrevCellId).classList.add('font-bold');
                    }
                    if (!isStepMode) await sleep(ANIMATION_SPEED * 1.5);
                    yield;

                    // STAGE 3: Calculate final value and update cell
                    ca[i][j] = Math.max(currentDist, prevDist);
                    cell.textContent = ca[i][j].toFixed(1);
                    cell.classList.remove('table-cell-highlight');
                    if (minPrevCellId) {
                         document.getElementById(minPrevCellId).classList.remove('font-bold');
                    }
                    candidates.forEach(c => document.getElementById(c.id)?.classList.remove('table-cell-path'));
                    if (!isStepMode) await sleep(ANIMATION_SPEED);
                    yield;
                }
            }
            
            const finalDist = ca[m - 1][n - 1];
            document.getElementById(`cell-${m-1}-${n-1}`).classList.add('table-cell-final');
            resultDiv.innerHTML = `<p class="text-2xl font-bold text-green-600">Fréchet Distance: ${finalDist.toFixed(2)}</p>`;
            statusP.textContent = 'Calculation complete. Tracing optimal path...';
            yield;
            
            const tracebackGen = tracebackPathGenerator(P, Q, ca);
            for (const _ of tracebackGen) {
                 if(!isStepMode) await sleep(ANIMATION_SPEED);
                 yield;
            }

            statusP.textContent = 'Optimal path shown.';
            isCalculating = false;
            toggleButtons(true);
            nextStepBtn.classList.add('hidden');
        }

        function* tracebackPathGenerator(P, Q, ca) {
            let i = P.length - 1;
            let j = Q.length - 1;
            const pathLeashes = [];

            while (i >= 0 && j >= 0) {
                document.getElementById(`cell-${i}-${j}`).classList.add('table-cell-traceback');
                pathLeashes.unshift({ p1: P[i], p2: Q[j] });
                redrawCanvas(null, pathLeashes);
                yield;

                if (i === 0 && j === 0) break;
                
                const candidates = [];
                if (i > 0) candidates.push({ val: ca[i-1][j], ni: i-1, nj: j});
                if (j > 0) candidates.push({ val: ca[i][j-1], ni: i, nj: j-1});
                if (i > 0 && j > 0) candidates.push({ val: ca[i-1][j-1], ni: i-1, nj: j-1});

                let bestCand = candidates.sort((a,b) => a.val - b.val)[0];
                
                i = bestCand.ni;
                j = bestCand.nj;
            }
        }

        // --- Initial Setup ---
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        setDrawingMode(1);
    </script>
</body>
</html>